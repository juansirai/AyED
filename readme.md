<h1>Algoritmos y Estructuras de Datos</h1>
<h3>Universidad Nacional de La Plata<br>
2022</h3>

<img src="http://ahorasomos.izertis.com/solidgear/wp-content/uploads/2016/08/technology-1283624_770.jpg" width="1000" height="200" alt="algorithm">

<h2>Propósito de este repositorio</h2>

En el presente repositorio se organizará todo el material teórico y práctico correspondiente a la materia
`Algoritmos y Estructuras de Datos` año 2022.

<h2>Material Teoria</h2>

* <a href="https://github.com/juansirai/AyED/blob/master/Ejercitaciones%20Teoricas/Arboles/resolucion.md">Practica repaso Arboles</a>
* <a href="https://github.com/juansirai/AyED/blob/master/Ejercitaciones%20Teoricas/Heap/practicaHeap.md">Practica repaso HEAP</a>
------------------------------------------
<h2>Practicas Resueltas</h2>

<h3> <a href="https://github.com/juansirai/AyED/blob/master/2%20-%20Semana%202/Practica/2022_TP01B_Introduccion_al_Lenguaje_Java..pdf" >
✨Practica 1 </a></h3>

* <a href="https://github.com/juansirai/AyED/tree/master/2%20-%20Semana%202/Practica/Practica1B/src/Ejercicio01">Ejercicio 1</a>
* <a href="https://github.com/juansirai/AyED/tree/master/2%20-%20Semana%202/Practica/Practica1B/src/Ejercicio02">Ejercicio 2</a>
* <a href="https://github.com/juansirai/AyED/tree/master/2%20-%20Semana%202/Practica/Practica1B/src/ejercicio03">Ejercicio 3</a>
* <a href="https://github.com/juansirai/AyED/tree/master/2%20-%20Semana%202/Practica/Practica1B/src/ejercicio05">Ejercicio 5</a>

<h3><a href="https://github.com/juansirai/AyED/blob/master/3%20-%20Semana%203/Practica/2022_TP02_Listas.pdf">✨Practica 2 </a></h3>

* <a href="https://github.com/juansirai/AyED/tree/master/3%20-%20Semana%203/Practica/ListasDeEnteros/src/ejercicio01">Ejercicio 1.2 y 1.3</a>
* <a href="https://github.com/juansirai/AyED/tree/master/3%20-%20Semana%203/Practica/ListasDeEnteros/src/ejercicio1_5https://github.com/juansirai/AyED/tree/master/3%20-%20Semana%203/Practica/ListasDeEnteros/src/ejercicio1_5">Ejercicio 1.5</a>
* <a href="https://github.com/juansirai/AyED/tree/master/3%20-%20Semana%203/Practica/ListasDeEnteros/src/ejercicio1_6">Ejercicio 1.6</a>
* <a href="https://github.com/juansirai/AyED/tree/master/3%20-%20Semana%203/Practica/ListasGenericas/src/ejercicios_parte2">Ejercicio 2</a>
* <a href="https://github.com/juansirai/AyED/tree/master/3%20-%20Semana%203/Practica/ListasGenericas/src/tp02/ejercicio2">Ejercicio 3</a>
* <a href="https://github.com/juansirai/AyED/blob/master/3%20-%20Semana%203/Practica/ListasGenericas/src/tp02/ejercicio2/TestBalanceo.java">Ejercicio 4</a>

<h3><a href="https://github.com/juansirai/AyED/blob/master/5%20-%20Semana%205/Practica/2022_TP03_AB.pdf">✨Practica 3 </a></h3>

* <a href="https://github.com/juansirai/AyED/tree/master/AyED/src/tp03/ejercicio1">Ejercicio 2</a>
* <a href="https://github.com/juansirai/AyED/tree/master/AyED/src/tp03/ejercicio3">Ejercicio 3</a>
* <a href="https://github.com/juansirai/AyED/tree/master/AyED/src/tp03/ejercicio4">Ejercicio 4</a>
* <a href="https://github.com/juansirai/AyED/tree/master/AyED/src/tp03/ejercicio5">Ejercicio 5</a>

<h3><a href="https://github.com/juansirai/AyED/blob/master/7%20-%20Semana%207/2022_TP04_AG.pdf">✨Practica 4 </a></h3>

* <a href="https://github.com/juansirai/AyED/blob/master/7%20-%20Semana%207/ejercicio2.md">Ejercicio 2</a>
* <a href="https://github.com/juansirai/AyED/blob/master/AyED/src/tp04/ejercicio1/RecorridosAG.java">Ejercicio 3</a>
* <a href="https://github.com/juansirai/AyED/blob/master/AyED/src/tp04/ejercicio1/ArbolGeneral.java">Ejercicio 4</a>
* <a href="https://github.com/juansirai/AyED/blob/master/AyED/src/tp04/ejercicio3/AnalizadorArbol.java">Ejercicio 5</a>
* <a href="https://github.com/juansirai/AyED/blob/master/AyED/src/tp04/ejercicio1/ArbolGeneral.java">Ejercicio 6</a>
* <a href="https://github.com/juansirai/AyED/tree/master/AyED/src/tp04/ejercicio7">Ejercicio 7</a>



<h3><a href="https://github.com/juansirai/AyED/tree/master/TP%2005">✨Practica 5 </a></h3>

* <a href="https://github.com/juansirai/AyED/blob/master/TP%2005/ejercicio01.md">Ejercicio 1</a>
* <a href="https://github.com/juansirai/AyED/blob/master/TP%2005/ejercicio02.md">Ejercicio 2</a>
* <a href="https://github.com/juansirai/AyED/blob/master/TP%2005/ejercicio03.md">Ejercicio 3</a>
* <a href="https://github.com/juansirai/AyED/blob/master/TP%2005/ejercicio04.md">Ejercicio 4</a>
* <a href="https://github.com/juansirai/AyED/blob/master/TP%2005/ejercicio05.md">Ejercicio 5</a>
* <a href="https://github.com/juansirai/AyED/blob/master/TP%2005/ejercicio06.md">Ejercicio 6</a>
* <a href="https://github.com/juansirai/AyED/blob/master/TP%2005/ejercicio07.md">Ejercicio 7</a>
* <a href="https://github.com/juansirai/AyED/blob/master/TP%2005/ejercicio08.md">Ejercicio 8</a>
* <a href="https://github.com/juansirai/AyED/blob/master/TP%2005/ejercicio09.md">Ejercicio 9</a>
* <a href="https://github.com/juansirai/AyED/blob/master/TP%2005/ejercicio10.md">Ejercicio 10</a>

---------------------------------------------------------------------------------------


<h2>Algoritmos Genéricos</h2>

<h3> Arreglos </h3>

`Busqueda Secuencial`:Arreglo desordenado
```java
public static int secSearch(int [] a, int key ){
  int index = -1;
  for (int i=0; i<N; i++){
    if(a[i] == key) index = i;
  }
  return index;
}
```

`Busqueda Binaria`: Arreglo ordenado

```java
public static int binarySearch(int [] a, int key){
  int lo = 0;
  int hi = a.lenght() - 1;
  while (lo <= hi){
    int mid = lo + (hi - lo) / 2;
    if(key < a[mid]) hi = mid-1;
    else if(key>a[mid]) lo = mid + 1;
    else return mid;
  }
  return -1;
}
```
`MergeSort`: Ordenación recursiva de vectores.

```java
public static void mergeSort(int[] a, int izq, int der){
  if(izq < der){
    int m = (izq + der) / 2;
    mergeSort(a, izq, m);
    mergSort(a, m+1, der);
    merge(a, izq, m, der);
  }
}

public static void merge(int[] a, int izq, int m, int der){
  int i, j, k;
  int[] b = new int[a.length];        // array auxiliar
  for(i=izq; i<= der; i++{
    b[i] = a[i];
  }
  i = izq; j = m+1; k = der;
  while(i<=m && j<=der){              // copia el sig elemento mas grande
    if(b[i]<= b[j])
      a[k++] = b[i++];
    else
      a[k++] = b[j++];
    }
  while(i<=m){                        // copia los elementos que quedan de la
    a[k++] = b[i++];                  // 1ra mitad(si los hay)
  }
}
```

`Maximo de un arreglo:`

```java
public class Calculadora {
  public static int maximo(int[] datos) {
    int max = 0;
    for (int i = 0; i < datos.length; i++) {
      if (datos[i] > max)
      max = datos[i];
    }
    return max;
  }
}
```

`Maximo y Minimo de un Arreglo`

```java
public class Calculadora {
 . . .
 public static Datos maxmin(int[] datos) {
   int max = 0, min = 9999;
   for (int i = 0; i < datos.length; i++) {
     if (datos[i] > max) max = datos[i];
     if (datos[i] < min) min=datos[i];
   }
   Datos obj = new Datos();
   obj.setMax(max);
   obj.setMin(min);
   return obj;
  }
}

// Luego tendriamos al objeto Datos
public class Datos {
  private int min;
  private int max;
  public int getMin() {
    return min;
  }
  public void setMin(int min) {
    this.min = min;
  }
  public int getMax() {
    return max;
  }
  public void setMax(int max) {
    this.max = max;
  }
}

```

<h3>Arboles</h3>

`Recorrido pre-orden`
*R-->HI-->HD*

```java
public void preorden() {
  imprimir (dato);
    si (tiene hijo_izquierdo)
      hijoIzquierdo.preorden();
    si (tiene hijo_derecho)
      hijoDerecho.preorden();
}
```

`Recorrido in-orden`:*HI --> R -->HD*

```java
	private void inOrden(ListaEnlazadaGenerica<Integer> lista, ArbolBinario<Integer> a){
		if(a.tieneHijoIzquierdo())
			inOrden(lista, a.getHijoIzquierdo());
		System.out.println(a.getDato());
		if(a.tieneHijoDerecho())
			inOrden(lista, a.getHijoDerecho());
	}
```

`Recorrido Pos-Orden`: *HI -->HD-->R*

```java
	private void posOrden(ListaEnlazadaGenerica<Integer> lista, ArbolBinario<Integer> a) {
		if(a.tieneHijoIzquierdo())
			posOrden(lista, a.getHijoIzquierdo());
		if(a.tieneHijoDerecho()) {
			posOrden(lista, a.getHijoDerecho());		}
		System.out.println(a.getDato());
	}
```

`Recorrido por niveles`

```java
public class ArbolBinario<T>{
  private T dato;
  private ArbolBinario<T> hijoIzquierdo;
  private ArbolBinario<T> hijoDerecho;

  public void recorridoPorNiveles(){
    ArbolBinario<T> arbol = null;
    ColaGenerica<ArbolBinario<T>> cola = new ColaGenerica <ArbolBinario<T>>();
    cola.encolar(this);
    cola.encolar(null);

    while(!cola.esVacia()){
      arbol = cola.desencolar();
      if (arbol != null){
        System.out.print(arbol.getDato());
        if(arbol.tieneHijoIzquierdo())
          cola.encolar(arbol.getHijoIzquierdo());
        if (arbol.tieneHijoDerecho())
          cola.encolar(arbol.getHijoDerecho());
      }
      else if (!cola.esVacia()){
        System.out.println();
        cola.encolar(null);
      }
    }
  }
}
```

`Es arbol Lleno?`

```java
public boolean lleno() {
  ArbolBinario<T> arbol = null;
  ColaGenerica<ArbolBinario<T>> cola = new ColaGenerica<ArbolBinario<T>>();
  boolean lleno = true;

  cola.encolar(this);
  int cant_nodos=0;
  cola.encolar( null);
  int nivel= 0;
  while (!cola.esVacia() && lleno) {
    arbol = cola.desencolar();

    if (arbol != null) {
      System.out.print(arbol.getDatoRaiz());
      if (!arbol.getHijoIzquierdo().esvacio()) {
        cola.encolar(arbol.getHijoIzquierdo());
        cant_nodos++;
      }

      if (!(arbol.getHijoDerecho().esvacio()) {
        cola.encolar(arbol.getHijoDerecho());
        cant_nodos++;
      }
    }
    else if (!cola.esVacia()) {
      if (cant_nodos == Math.pow(2, ++nivel)){
        cola.encolar( null);
        cant_nodos=0;
        System. out.println();
      }
      else lleno=false;}
    }
    return lleno;
  }
```

<h3>Arboles de Expresion</h3>

`A partir de una expresion postfija`

**a b d * c + * e f g * + +**

```java
tomo un carácter de la expresión
  mientras ( existe carácter ) hacer
    si es un operando  creo un nodo y lo apilo.
    si es un operador (lo tomo como la raíz de los dos últimos nodos creados)
      creo un nodo R,
      desapilo y lo agrego como hijo derecho de R
      desapilo y lo agrego como hijo izquierdo de R
      apilo R.
    tomo otro carácter
  fin
```

`Postfija en arbol binario`

```java
public ArbolBinario<Character> convertirPostfija(String exp) {
  Character c = null;
  ArbolBinario<Character> result;
  PilaGenerica<ArbolBinario<Character>> p = new PilaGenerica<ArbolBinario<Character>>();
  for (int i = 0; i < exp.length(); i++) {
    c = exp.charAt(i);
    result = new ArbolBinario<Character>(c);
    if ((c == '+') || (c == '-') || (c == '/') || (c == '*')) {
      // Es operador
      result.agregarHijoDerecho(p.desapilar());
      result.agregarHijoIzquierdo(p.desapilar ());
    }
    p.apilar(result);
  }
  return (p.desapilar());
}
```


` A partir de una expresion prefija`

```java
ArbolExpresión (A: ArbolBin, exp: string )
  si exp nulo
    nada.
  si es un operador
    creo un nodo raíz R
    ArbolExpresión (subArbIzq de R, exp(sin 1° carácter) )
    ArbolExpresión ( subArbDer de R, exp (sin 1° carácter) )
  si es un operando
    creo un nodo (hoja)
```
**/ *+abc+de**

```java
public ArbolBinario<Character> convertirPrefija(StringBuffer exp) {

  Character c = exp.charAt(0);
  ArbolBinario<Character> result = new ArbolBinario<Character>(c);
  if ((c == '+') || (c == '-') || (c == '/') || c == '*') {
    // es operador
    result.agregarHijoIzquierdo(this.convertirPrefija(exp.delete(0,1)));
    result.agregarHijoDerecho(this.convertirPrefija(exp.delete(0,1)));
  }
  // es operando
  return result;
}

```

`A partir de una expresion Infija`

Pasos:
* Se convierte a post fija
* A partir de ahi se crea el arbol.

¿Como se convierte a post fija?

```
  a)si es un operando ➡ se coloca en la salida.
  b) si es un operador ➡ se maneja una pila según la prioridad del operador en relación al tope de la pila
    operador con > prioridad que el tope –> se apila
    operador con <= prioridad que el tope –> se desapila elemento colocándolo en la salida.
    Se vuelve a comparar el operador con el tope de la pila
  c) si es un “(“ , “)” ➡
    “(“ se apila
    “)” se desapila todo hasta el “(“, incluído éste
  d) cuando se llega al final de la expresión, se desapilan todos los elementos llevándolos a la salida, hasta que la pila quede vacía
  ```

  `Evaluacion de Arbol`

*Este método evalúa y retorna un número de acuerdo a la expresión aritmética representada por el ArbolBinario que es enviado como parámetro*
  ```java
public Integer evaluar(ArbolBinario<Character> arbol) {
  Character c = arbol.getDato();
  if ((c == '+') || (c == '-') || (c == '/') || c == '*') {
    // es operador
    int operador_1 = evaluar(arbol.getHijoIzquierdo());
    int operador_2 = evaluar(arbol.getHijoDerecho());
    switch (c) {
      case '+':
        return operador_1 + operador_2;
      case '-':
        return operador_1 - operador_2;
      case '*':
        return operador_1 * operador_2;
      case '/':
        return operador_1 / operador_2;
      }
    }
    // es operando
    return Integer.parseInt(c.toString());
  }
  ```

<h3> Arboles Generales </h3>

`Recorrido Pre Orden`

```java
public void preOrden() {
  imprimir (dato);
  obtener lista de hijos;
  mientras (lista tenga datos) {  
    hijo obtenerHijo;
    hijo.preOrden();
  }
}

// implementacion en Java

package ayed;
public class ArbolGeneral<T> {
public ListaEnlazadaGenerica<T> preOrden() {
	ListaEnlazadaGenerica<T> lis = new ListaEnlazadaGenerica<T>();
 	this.preOrden(lis);
 	return lis;
 	}

private void preOrden(ListaGenerica<T> l) {
 	l.agregarFinal(this.getDato());
 	ListaGenerica<ArbolGeneral<T>> lHijos = this.getHijos();
 	lHijos.comenzar();
 	while (!lHijos.fin()) {
 		(lHijos.proximo()).preOrden(l);
 	}
  }
 }
```

`Recorrido Post Orden`

```java
public void postOrden() {
  obtener lista de hijos;
  mientras (lista tenga datos) {  
    hijo obtenerHijo;
    hijo.postOrden();
  }
  imprimir (dato);
}
```

`Recorrido Por Niveles`

```java
public void porNiveles() {
  encolar(raíz);
  mientras cola no se vacíe {
    v := desencolar();
    imprimir (dato de v);
    para cada hijo de v
      encolar(hijo);
    }
  }
  
// implementacion en java

public ListaGenerica<T> porNiveles(ArbolGeneral<T> arbol) {
    ListaGenerica<T> result = new ListaEnlazadaGenerica<T>();
    ColaGenerica<ArbolGeneral<T>> cola= new ColaGenerica<ArbolGeneral<T>>();
    ArbolGeneral<T> arbol_aux;
    
    cola.encolar(arbol);
    while (!cola.esVacia()) {
        arbol_aux = cola.desencolar();
        result.agregarFinal(arbol_aux.getDato());
        if (arbol_aux.tieneHijos()) {
            ListaGenerica<ArbolGeneral<T>> hijos = arbol_aux.getHijos();
            hijos.comenzar();
            while (!hijos.fin()) {
                cola.encolar(hijos.proximo());
            }
         }
      }
    return result;
}


```

`Contar cantidad de niveles`
```java
Seudocódigo Ejerc1-Niveles {
  q: cola de vértices;
  encolar raíz R en q;
  encolar null en q;
  cantNiveles:= 0;

  mientras (cola no se vacíe) {
    desencolar v de q;
    si (dato de v no es ??) {
      imprimir (dato de v);
      para cada hijo w de v
        encolar w en q;
      }
  sino
    si (q no está vacía)
    encolar null en q;
    cantNiveles++;
  }
  return cantNiveles;
}
```

`Contar Nodos`
```java
Seudocódigo Ejerc1-Niveles {
  q: cola de vértices;
  cantNodods: ArrayEnteros;

  encolar raíz R en q;
  encolar null en q;
  cantNiveles:= 0;

  mientras (cola no se vacíe) {
    desencolar v de q;
    si (dato de v no es null) {
      imprimir (dato de v);
      cantNodos[nroNivel]++;
      para cada hijo w de v
        encolar w en q;
      }
  sino
    si (q no está vacía)
    encolar null en q;
    cantNiveles++;
  }
  return cantNodos;
}
```
